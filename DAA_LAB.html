


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="(link unavailable)">
    <link rel="stylesheet" href="style.css">
    <title>Portfolio Website</title>
    <style>
        h2 {
            font-size: 28px;
            /* Increase the size of headings */
            margin-bottom: 10px;
            /* Add some spacing below headings */
        }

        ul, li {
            font-size: 18px;
            /* Increase the size of list items */
            line-height: 1.8;
            /* Add spacing between lines for better readability */
        }

        p {
            font-size: 18px;
            /* Increase the size of paragraphs */
        }

        a {
            text-decoration: none;
            /* Optional: Remove underline from links */
            color: #0066cc;
            /* Optional: Add a nice color to links */
        }

        d4 {
            font-size: 30px;
            /* Adjust this value to increase the size */
            line-height: 1.8;
            /* Optional: Increase spacing between lines */
        }

        d4 dt {
            font-weight: bold;
            /* Optional: Make definition terms bold */
        }

        d4 dd {
            margin-left: 20px;
            /* Optional: Add spacing to the descriptions */
        }
    </style>
</head>

<body>
    <header>
        <a href="#" class="logo">DAA</a>
    </header>
    <section class="home">
        <div class="home-content">
            <h2>Lab Reflections</h2>
            <h2>1. Time Complexity Analysis</h2>
            <p style="color: white;"> 
                1. Overcoming Challenges in Understanding Time Complexity<br>
                - Mastering asymptotic notations and their implications.<br>
                - Breaking down algorithms into manageable steps for analysis.<br>
                - Relating theoretical concepts to practical applications.<br><br>
                2. Bridging the Gap between Theory and Real-World Applications<br>
                - Selecting the most suitable algorithm based on input size and constraints.<br>
                - Evaluating the efficiency of algorithms in real-world scenarios.<br><br>
                3. Identifying the Most Efficient Approach<br>
                - Analyzing problem constraints and input size to inform algorithm choice.<br>
                - Testing and profiling algorithms to validate theoretical efficiency.
            </p>
            <h2>2. Binary Search Tree</h2>
            <p style="color: white;"> 
                1. Challenges in Learning and Understanding BSTs<br>
                - Visualizing the tree structure and node connections.<br>
                - Mastering different traversal techniques.<br><br>
                2. Applying BST Concepts to Real-World Problems<br>
                - Recognizing the value of BSTs in efficient data storage and retrieval.<br>
                - Ensuring the BST remains balanced for optimal performance.<br><br>
                3. Determining the Most Efficient Approach<br>
                - Identifying whether the problem involves ordered data or frequent searches.<br>
                - Comparing BST with other data structures to determine the best fit.
                <pre>
                    <code>
                        // BST code remains the same
                    </code>
                </pre>
            </p>
            <h2>Algorithmic Concepts</h2>
            <h2>3. DFS and BFS</h2>
            <p style="color: white;"> 
                1. Overcoming Challenges in Learning and Understanding DFS and BFS<br>
                - Grasping the difference between depth-first and level-wise traversal.<br>
                - Visualizing the traversal process.<br>
                - Implementing recursive and iterative solutions effectively.<br><br>
                2. Applying DFS and BFS to Real-World Problems<br>
                - Recognizing the value of DFS and BFS in web crawling, social network analysis, and more.<br>
                - Evaluating the efficiency of these algorithms in real-world scenarios.<br><br>
                3. Identifying the Most Efficient Approach<br>
                - Determining whether the problem requires depth exploration or level exploration.<br>
                - Comparing DFS and BFS based on complexity and specific needs.
                <pre>
                    <code>
                        // DFS and BFS code remains the same
                    </code>
                </pre>
            </p>
            <ul>
                <li><strong>Segment Tree:</strong> Efficiently handles range queries.</li>
                <li><strong>Fenwick Tree:</strong> Optimized for cumulative frequency queries.</li>
                <li><strong>Sparse Table:</strong>

    <section id="backtracking-algorithms">
        <h2>Backtracking Algorithms: Finding All Possible Solutions</h2>
        <img src="(link unavailable)" alt="Backtracking Algorithms" style="width: 100%; height: 500px; object-fit: cover;">
        <p>Backtracking algorithms are used to find all possible solutions to a problem by exploring all possible options. They work by recursively trying each option and backtracking when a dead end is reached. Backtracking algorithms are often used for solving puzzles, such as Sudoku, crosswords, and chess.</p>
        <h3>Key Elements of Backtracking Algorithms</h3>
        <ul>
            <li><strong>Recursive function:</strong> Use a recursive function to explore all possible options.</li>
            <li><strong>Backtracking:</strong> Backtrack when a dead end is reached.</li>
            <li><strong>Exploring all options:</strong> Explore all possible options to find all possible solutions.</li>
        </ul>
        <h3>Examples of Backtracking Algorithms</h3>
        <ul>
            <li><strong>Sudoku:</strong> Solve Sudoku puzzles using a backtracking algorithm.</li>
            <li><strong>Crosswords:</strong> Solve crosswords using a backtracking algorithm.</li>
            <li><strong>Chess:</strong> Use a backtracking algorithm to find all possible moves in a game of chess.</li>
        </ul>
    </section>
    <section id="divide-and-conquer-algorithms">
        <h2>Divide and Conquer Algorithms: Breaking Down Complex Problems</h2>
        <img src="(link unavailable)" alt="Divide and Conquer Algorithms" style="width: 100%; height: 500px; object-fit: cover;">
        <p>Divide and conquer algorithms work by breaking down complex problems into smaller sub-problems, solving each sub-problem, and then combining the solutions to solve the original problem. They are often used for sorting, searching, and merging data.</p>
        <h3>Key Elements of Divide and Conquer Algorithms</h3>
        <ul>
            <li><strong>Breaking down the problem:</strong> Break down the complex problem into smaller sub-problems.</li>
            <li><strong>Solving sub-problems:</strong> Solve each sub-problem recursively.</li>
            <li><strong>Combining solutions:</strong> Combine the solutions to the sub-problems to solve the original problem.</li>
        </ul>
        <h3>Examples of Divide and Conquer Algorithms</h3>
        <ul>
            <li><strong>Merge sort:</strong> Sort data using the merge sort algorithm.</li>
            <li><strong>Quick sort:</strong> Sort data using the quick sort algorithm.</li>
            <li><strong>Binary search:</strong> Search for data using the binary search algorithm.</li>
        </ul>
    </section>
    <section id="graph-algorithms">
        <h2>Graph Algorithms: Working with Graphs</h2>
        <img src="(link unavailable)" alt="Graph Algorithms" style="width: 100%; height: 500px; object-fit: cover;">
        <p>Graph algorithms are used to work with graphs, which are non-linear data structures consisting of nodes and edges. They are often used for finding the shortest path between two nodes, finding the minimum spanning tree of a graph, and testing whether a graph is connected.</p>
        <h3>Key Elements of Graph Algorithms</h3>
        <ul>
            <li><strong>Graph representation:</strong> Represent the graph using an adjacency matrix or adjacency list.</li>
            <li><strong>Graph traversal:</strong> Traverse the graph using depth-first search or breadth-first search.</li>
            <li><strong>Shortest path:</strong> Find the shortest path between two nodes using Dijkstra's algorithm or Bellman-Ford algorithm.</li>
        </ul>
        <h3>Examples of Graph Algorithms</h3>
        <ul>
            <li><strong>Dijkstra's algorithm:</strong> Find the shortest path between two nodes using Dijkstra's algorithm.</li>
            <li><strong>Bellman-Ford algorithm:</strong> Find the shortest path between two nodes using Bellman-Ford algorithm.</li>
            <li><strong>Topological sort:</strong> Perform a topological sort on a directed acyclic graph.</li>
        </ul>
    </section>
    <section id="dynamic-programming-algorithms">
        <h2>Dynamic Programming Algorithms: Solving Complex Problems</h2>
        <img src="(link unavailable)" alt="Dynamic Programming Algorithms" style="width: 100%; height: 500px; object-fit: cover;">
        <p>Dynamic programming algorithms are used to solve complex problems

        <p>...by breaking them down into smaller sub-problems, solving each sub-problem only once, and storing the solutions to sub-problems to avoid redundant computation. They are often used for solving optimization problems, counting problems, and finding the longest or shortest path in a graph.</p>
        <h3>Key Elements of Dynamic Programming Algorithms</h3>
        <ul>
            <li><strong>Breaking down the problem:</strong> Break down the complex problem into smaller sub-problems.</li>
            <li><strong>Overlapping sub-problems:</strong> The sub-problems may have some overlap, meaning that some sub-problems may be identical or have similar solutions.</li>
            <li><strong>Optimal substructure:</strong> The problem can be broken down into smaller sub-problems, and the optimal solution to the larger problem can be constructed from the optimal solutions of the sub-problems.</li>
            <li><strong>Memoization:</strong> Store the solutions to sub-problems to avoid redundant computation.</li>
        </ul>
        <h3>Examples of Dynamic Programming Algorithms</h3>
        <ul>
            <li><strong>Fibonacci series:</strong> Calculate the nth Fibonacci number using dynamic programming.</li>
            <li><strong>Longest common subsequence:</strong> Find the longest common subsequence between two strings using dynamic programming.</li>
            <li><strong>Shortest path problems:</strong> Solve shortest path problems using dynamic programming.</li>
        </ul>
    </section>
    <section id="greedy-algorithms">
        <h2>Greedy Algorithms: Making Locally Optimal Choices</h2>
        <img src="(link unavailable)" alt="Greedy Algorithms" style="width: 100%; height: 500px; object-fit: cover;">
        <p>Greedy algorithms make locally optimal choices at each step with the hope of finding a global optimum solution. They are often used for solving optimization problems, such as finding the minimum or maximum of a function, or finding the shortest path in a graph.</p>
        <h3>Key Elements of Greedy Algorithms</h3>
        <ul>
            <li><strong>Greedy choice:</strong> Make a locally optimal choice at each step.</li>
            <li><strong>Hope for global optimum:</strong> Hope that the locally optimal choices lead to a global optimum solution.</li>
            <li><strong>No backtracking:</strong> Greedy algorithms do not backtrack or reconsider previous choices.</li>
        </ul>
        <h3>Examples of Greedy Algorithms</h3>
        <ul>
            <li><strong>Huffman coding:</strong> Construct a Huffman tree using a greedy algorithm.</li>
            <li><strong>Activity selection problem:</strong> Select the maximum number of activities that can be performed by a single person using a greedy algorithm.</li>
            <li><strong>Fractional knapsack problem:</strong> Solve the fractional knapsack problem using a greedy algorithm.</li>
        </ul>
    </section>
    <section id="backtracking-algorithms">
        <h2>Backtracking Algorithms: Finding All Possible Solutions</h2>
        <img src="(link unavailable)" alt="Backtracking Algorithms" style="width: 100%; height: 500px; object-fit: cover;">
        <p>Backtracking algorithms are used to find all possible solutions to a problem by exploring all possible options. They are often used for solving puzzles, such as Sudoku, crosswords, and chess.</p>
        <h3>Key Elements of Backtracking Algorithms</h3>
        <ul>
            <li><strong>Recursive function:</strong> Use a recursive function to explore all possible options.</li>
            <li><strong>Backtracking:</strong> Backtrack when a dead end is reached.</li>
            <li><strong>Exploring all options:</strong> Explore all possible options to find all possible solutions.</li>
        </ul>
        <h3>Examples of Backtracking Algorithms</h3>
        <ul>
            <li><strong>Sudoku:</strong> Solve Sudoku puzzles using a backtracking algorithm.</li>
            <li><strong>Crosswords:</strong> Solve crosswords using a backtracking algorithm.</li>
            <li><strong>Chess:</strong> Use a backtracking algorithm to find all possible moves in a game of chess.</li>
        </ul>
    </section>
</body>
</html>
                                <pre>
                    <code>
                #include<iostream>
#include<cstdlib>
//#define NULL 0
using namespace std;

struct tree
{
    int data;
    struct tree*left;
    struct tree *right;
};
typedef struct tree TREE;


class binarysearchtree
{
public:
    TREE*insert_into_bst(TREE*,int);
    void inorder(TREE*);
    void preorder(TREE*);
    void postorder(TREE*);
    int total_nodes(TREE* );
    void printOutDegreeOfRoot(TREE* root);
    TREE* delete_from_bst(TREE*, int);
    TREE* delete_less_than_k(TREE*,int);
    void minimum(TREE*);
    void maximum(TREE*);
    int GreaterThanK(TREE*,int);
    int LesserThanK(TREE*,int);
};
void binarysearchtree::minimum(TREE* root){
   int Min=root->data;
   while(root->left!=NULL) root=root->left;
   Min=root->data;
   cout<<"Min value is "<<Min<<endl;
}
int binarysearchtree::GreaterThanK(TREE* root,int k){
   int sum=0;
   if(root==NULL){
    return 0;
   }
   if(root->data==k) return total_nodes(root->right);
   else if(root->data>k){
    sum=total_nodes(root->right)+1;
    sum=sum+GreaterThanK(root->left,k);
    return sum;
   }
   else{
    return GreaterThanK(root->right,k);
   }
}

int binarysearchtree::LesserThanK(TREE* root,int k){
   int sum=0;
   if(root==NULL) return 0;
   if(root->data==k) return total_nodes(root->left);
   else if(root->data<k){
    sum=1+total_nodes(root->left);
    sum=sum+LesserThanK(root->right,k);
    return sum;
   }
   else{
    return LesserThanK(root->left,k);
   }
}

void binarysearchtree::maximum(TREE* root){
   int Max=root->data;
   while(root->right!=NULL) root=root->right;
   Max=root->data;
   cout<<"Max value is "<<Max<<endl;
}
TREE* binarysearchtree::delete_less_than_k(TREE* root,int k){
   if(root==NULL) return root;
   root->left=delete_less_than_k(root->left,k);
   root->right=delete_less_than_k(root->right,k);
   if(root->data<k){
    TREE* temp=root->right;
    root=delete_from_bst(root,root->data);
   }
   return root;
}
TREE* binarysearchtree::insert_into_bst(TREE* root,int data)
{
    TREE* newnode=(TREE*)malloc(sizeof(TREE));
    if(newnode==NULL)
    {
        cout<<"memory allocation failed\n";
        return root;
    }

    newnode->data=data;
    newnode->left=NULL;
    newnode->right=NULL;

    if(root==NULL)
    {
        root=newnode;
        cout<<"root node inserted into tree\n";
        return root;
    }

    TREE*currnode=root;
    TREE* parent=NULL;

    while(currnode!=NULL)
    {
        parent=currnode;
        if(newnode->data<currnode->data)
            currnode=currnode->left;
        else
            currnode=currnode->right;
    }


    if(newnode->data<parent->data)
        parent->left=newnode;
    else
        parent->right=newnode;
    cout<<"node inserted successfully into the tree"<<endl;
    return root;
}

void binarysearchtree::inorder(TREE* root)
{
    if(root!=NULL)
    {
        inorder(root->left);
        cout<<root->data<<"\t";
        inorder(root->right);
    }
}

void binarysearchtree::preorder(TREE* root)
{
    if(root!=NULL)
    {
        cout<<root->data<<"\t";
        preorder(root->left);
        preorder(root->right);
    }
}

void binarysearchtree::postorder(TREE* root)
{
    if(root!=NULL)
    {
        postorder(root->left);
        postorder(root->right);
        cout<<root->data<<"\t";
    }
}

TREE* binarysearchtree::delete_from_bst(TREE* root,int data)
{
    TREE* currnode=root;
    TREE* parent =NULL;
    TREE* successor =NULL;
    TREE* p=NULL;

    if(root==NULL)
    {
        cout<<"tree is empty\n";
        return root;
    }
    while(currnode!=NULL&&currnode->data!=data)
    {
        parent=currnode;
        if(data<currnode->data)
            currnode=currnode->left;
        else
            currnode=currnode->right;
    }
    if(currnode==NULL)
    {
        cout<<"item not found\n";
        return root;
    }
    if(currnode->left==NULL)
        p=currnode->right;
    else if(currnode->right==NULL)
        p=currnode->left;
    else{
        successor=currnode->right;
        while(successor->left!=NULL)
            successor=successor->left;
        successor->left=currnode->left;
        p=currnode->right;
    }

    if(parent==NULL)
    {
        free(currnode);
        return p;
    }
    if(currnode==parent->left)
        parent->left=p;
    else
        parent->right=p;
     free(currnode);
    return root;
}
int binarysearchtree::total_nodes(TREE* root){
   if(root==NULL) return 0;
   return 1+total_nodes(root->left)+total_nodes(root->right);
}
void binarysearchtree::printOutDegreeOfRoot(TREE* root){
   if(root->left==NULL&&root->right==NULL) cout<<"Out degree of root node = 0\n";
   else if(root->left!=NULL&&root->right!=NULL) cout<<"Out degree of root node = 2\n";
   else cout<<"Out degree of root node = 1\n";
}

int main()
{
    binarysearchtree bst;
    TREE* root=NULL;
    int ch=0,k;
    int data=0;
    while(1)
    {
        cout<<"\n menu\n";
        cout<<"1-insert into bst\n";
        cout<<"2-inorder traversal\n";
cout<<"3-preorder traversal\n";
cout<<"4-postorder traversal\n";
cout<<"5-delete from bst\n";
cout<<"6-total number of nodes\n";
cout<<"7-total number of edges\n";
cout<<"8-outdegree\n";
cout <<"9-Delete less than k\n";
cout <<"10-Minimum in the tree\n";
cout <<"11-Maximum in the tree\n";
cout <<"12-No. of nodes greater than k\n";
cout <<"13-No. of nodes lesser than k\n";
cout<<"enter your choice\n";
cin>>ch;
switch(ch)
{
    case 1:
                cout<<"enter the item to insert:";
                cin>>data;
                root=bst.insert_into_bst(root,data);
                break;
    case 2:
                if(root==NULL)
                    cout<<"tree is empty\n";
                else{
                    cout<<"inorder traversal is..\n";
                    bst.inorder(root);
                }
                break;
    case 3:
                if(root==NULL)
                    cout<<"tree is empty\n";
                else{
                    cout<<"preorder traversal is..\n";
                    bst.preorder(root);
                }
                break;
    case 4:
                if(root==NULL)
                    cout<<"tree is empty\n";
                else{
                    cout<<"postorder traversal is..\n";
                    bst.postorder(root);
                }
                break;
    case 5:
               cout<<"enter the item to be deleted:";
               cin>>data;
               root=bst.delete_from_bst(root,data);
                break;
    case 6:
                cout<<"total number of nodes "<<bst.total_nodes(root)<<endl;break;
    case 7:
                cout<<"total edges = "<<bst.total_nodes(root)-1<<endl;break;
    case 8:
                 bst.printOutDegreeOfRoot(root);break;
    case 9:
                cout<<"enter the value of k\n";
                 cin>>k;
                 root=bst.delete_less_than_k(root,k);
                 cout<<"deleted";
        break;
    case 10:
        bst.minimum(root);
        break;
    case 11:
        bst.maximum(root);
        break;
    case 12:
        cout<<"enter the value of k\n";
        cin>>k;
        cout<<"The no. of nodes greater than k = "<<bst.GreaterThanK(root,k);
        break;
    case 13:
        cout<<"enter the value of k\n";
        cin>>k;
        cout<<"The no. of nodes lesser than k = "<<bst.LesserThanK(root,k);
        break;
    default:
                cout<<"exiting code\n";
                exit(0);
        }
    }
    return 0;
}
            </code>
                </pre>


            </p>
            <h2>Algorithmic Concepts</h2>
            <h2>3. DFS and BFS</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding DFS and BFS<br>
                - Grasping the depth-first (DFS) vs. level-wise (BFS) approach.<br>
                - Picturing traversal processes.<br>
                - Writing effective code, managing recursion for DFS and queues for BFS.<br>
                - Avoiding infinite loops in graphs with cycles.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting the theory to practical uses like web crawling or social network analysis.<br>
                - Evaluating efficiency in real-world scenarios.<br>
                - Applying algorithms to large-scale systems, like network routing.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify the problem type—depth exploration (DFS) vs. level exploration (BFS).<br>
                - Evaluate based on complexity and specific needs.<br>
                - Implement both, test, and compare.
                <pre>
                    <code>
                        #include <iostream>
using namespace std;

void bfs(int m[10][10], int v, int source) {
    int queue[20];
    int front = 0, rear = 0, u, i;
    int visited[10];

    for (i = 0; i < v; i++)
        visited[i] = 0;

    queue[rear] = source;
    visited[source] = 1;

    cout << "The BFS Traversal is... \n";

    while (front <= rear) {
        u = queue[front];
        cout << u+1 << "\t";
        front++;

        for (i = 0; i < v; i++) {
            if (m[u][i] == 1 && visited[i] == 0) {
                visited[i] = 1;
                rear++;
                queue[rear] = i;
            }
        }
    }
}

int main() {
      int v = 6;
    int m[10][10] = {{0,1,1,0,0,0}, {1,0,0,1,0,0},
        {1,0,0,1,1,0},{0,1,1,0,1,1},{0,0,1,1,0,0},{0,0,0,1,0,0}};

    int source;
    cout << "Enter the source vertex: ";
    cin >> source;

    bfs(m, v, source-1);

    return 0;
}




class Solution {
public:
    bool check(unordered_map<int, vector<int>> &mp, int s, int d, vector<bool>& visited) {
        if(s == d) //if source is equal to destination
            return true;

        if(visited[s] == true) //already visited to avoid repetition here we mark it as false
            return false;

        visited[s] = true;//not to visit again so marking the node visited

        for(auto &node : mp[s]) {
            if(check(mp, node, d, visited) == true) //if the root node of source code haas any connection with destination code then return true else false
                return true;
        }

        return false;
    }

    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
        //define a adj list
        unordered_map<int, vector<int>> mp;

        vector<bool>visited(n, false);

        for(vector<int>& edge : edges) {
            int u = edge[0];
            int v = edge[1];

            //for bi-direactional graph
            mp[u].push_back(v);
            mp[v].push_back(u);

        }
        return check(mp, source, destination, visited);
    }
};
expalin this

                    </code>
                </pre>
            </p>
            <ul>
                <li><strong>Segment Tree:</strong> Handles range queries efficiently.</li>
                <li><strong>Fenwick Tree:</strong> Optimized for cumulative frequency queries.</li>
                <li><strong>Sparse Table:</strong> Precomputes answers for range queries.</li>
            </ul>
            <h2>4. Heap</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Heaps<br>
                - Understanding the binary tree representation of heaps.<br>
                - Grasping the min-heap and max-heap properties.<br>
                - Writing efficient code for insertion, deletion, and heapify operations.<br>
                - Visualizing the heap structure and operations.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting heap concepts to real-world uses like priority queues and scheduling.<br>
                - Evaluating efficiency in practical scenarios.<br>
                - Applying heaps to large-scale data processing tasks.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify if the problem requires a priority-based approach.<br>
                - Evaluate heap against other data structures for suitability.<br>
                - Implement and test the heap operations.
                <pre>
                    <code>
                        #include <iostream>
#include <vector>

using namespace std;

// Heapify function to maintain the max-heap property
void heapify(vector<int>& heap, int n, int i) {
    int largest = i; // Initialize largest as root
    int left = 2 * i + 1; // left child
    int right = 2 * i + 2; // right child

    // If left child is larger than root
    if (left < n && heap[left] > heap[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && heap[right] > heap[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(heap[i], heap[largest]);

        // Recursively heapify the affected sub-tree
        heapify(heap, n, largest);
    }
}

// Bottom-up heap construction
void buildMaxHeap(vector<int>& heap, int n) {
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(heap, n, i);
}

// Insert a new element into the heap
void insertElement(vector<int>& heap, int value) {
    heap.push_back(value);
    int i = heap.size() - 1;

    // Fix the max heap property after insertion
    while (i != 0 && heap[(i - 1) / 2] < heap[i]) {
        swap(heap[i], heap[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

// Delete the root element from the heap
void deleteRoot(vector<int>& heap) {
    int n = heap.size();
    if (n == 0) {
        cout << "Heap is empty!" << endl;
        return;
    }

    // Replace root with the last element
    heap[0] = heap[n - 1];
    heap.pop_back(); // Remove the last element

    // Heapify the new root
    heapify(heap, heap.size(), 0);
}

// Print the elements of the heap
void printHeap(const vector<int>& heap) {
    for (int i : heap)
        cout << i << " ";
    cout << endl;
}

// Print the root element of the heap
void printRoot(const vector<int>& heap) {
    if (!heap.empty())
        cout << "Root: " << heap[0] << endl;
    else
        cout << "Heap is empty!" << endl;
}

int main() {
    vector<int> heap;
    int choice, value;

  /*  cout << "Enter the number of elements to create the heap: ";
    int n;
    cin >> n;

    cout << "Enter the elements: ";
    for (int i = 0; i < n; ++i) {
        cin >> value;
        heap.push_back(value);
    }
*/
    // Build the max-heap
    buildMaxHeap(heap, heap.size());

    do {
        cout << "\nMenu: \n1. Insert\n2. Delete Root\n3. Print Heap\n4. Print Root\n5. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> value;
                insertElement(heap, value);
                break;

            case 2:
                deleteRoot(heap);
                break;

            case 3:
                cout << "Heap: ";
                printHeap(heap);
                break;

            case 4:
                printRoot(heap);
                break;

            case 5:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice. Try again.\n";
        }
    } while (choice != 5);

    return 0;
}

                    </code>
                </pre>
            </p>
            
            <h2>5. Sorting</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Sorting Algorithms<br>
                - Understanding the logic behind different algorithms like Quick Sort, Merge Sort, and Heap Sort.<br>
                - Grasping the time and space complexity trade-offs for each algorithm.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting sorting concepts to tasks like organizing large datasets or ranking search results.<br>
                - Handling real-world constraints, such as memory limitations or specific ordering rules.<br><br>

                3. Determining the Efficient Approach<br>
                - Test and evaluate the chosen algorithm on real-world scenarios to ensure performance and reliability.
                <pre>
                    <code>
                        #include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;
#define CLOCKS_PER_SEC 100000
#define SIZE 5
#define ITER 10000

void insertionsort(int a[], int n)
{
    int x, j;
    for (int i = 1; i < n; i++)
    {
        x = a[i];
        j = i - 1;
        while (j >= 0 && a[j] > x)
        {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = x;
    }
}

int main()
{
    clock_t start, endt;
    double duration;

    int a[SIZE];
    srand(42);

    cout << "Unsorted array:" << endl;
    for (int i = 0; i < SIZE; i++)
    {
        a[i] = rand() % 100;
        cout << a[i] << " ";
    }
    cout << endl;

    start = clock();
    insertionsort(a, SIZE);
    endt = clock();

    duration = (double)(endt - start) / CLOCKS_PER_SEC;
    cout << "Sorted array:" << endl;
    for (int i = 0; i < SIZE; i++)
    {
        cout << a[i] << " ";
    }
    cout << endl;

    cout << "Time taken to sort the array in seconds: " << duration / ITER << endl;
    return 0;
}

                    </code>
                </pre>
            </p>
            <h2>6. Pattern Searching</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Pattern Searching Concepts<br>
                - Understanding logic, time, and space complexities of algorithms like KMP or Rabin-Karp.<br>
                - Handling special cases like overlapping patterns or empty strings.<br>
                - Debugging: Errors in implementation, especially with indexing or hash collisions.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Applying theoretical concepts to areas like DNA sequencing or log analysis.<br>
                - Ensuring algorithms perform efficiently on large datasets.<br>
                - Dealing with noise or inconsistent patterns in real-world data.<br><br>

                3. Determining the Most Efficient Approach/Design Techniques<br>
                - Define objectives and constraints (e.g., exact vs. approximate matching).<br>
                - Compare based on time/space complexity (e.g., KMP for repetitive patterns, Boyer-Moore for large texts).<br>
                - Preprocess data, use parallelism for large datasets, or adopt dynamic programming for complex problems.
                <pre>
                    <code>
                        #include <iostream>
#include <vector>
using namespace std;

// Function to compute the Longest Prefix Suffix (LPS) array
void computeLPSArray(const string& pattern, vector<int>& lps) {
    int length = 0; // length of the previous longest prefix suffix
    int i = 1;
    lps[0] = 0; // LPS of the first character is always 0

    while (i < pattern.length()) {
        if (pattern[i] == pattern[length]) {
            length++;
            lps[i] = length;
            i++;
        } else {
            if (length != 0) {
                length = lps[length - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

// Function to perform KMP pattern searching
void KMPSearch(const string& text, const string& pattern) {
    int textLength = text.length();
    int patternLength = pattern.length();

    // Create LPS array
    vector<int> lps(patternLength);
    computeLPSArray(pattern, lps);

    int i = 0; // index for text
    int j = 0; // index for pattern

    while (i < textLength) {
        if (pattern[j] == text[i]) {
            i++;
            j++;
        }

        if (j == patternLength) {
            cout << "Pattern found at index " << i - j << endl;
            j = lps[j - 1];
        } else if (i < textLength && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
}

int main() {
    string text = "ABABDABACDABABCABAB";
    string pattern = "ABABCABAB";

    cout << "Text: " << text << endl;
    cout << "Pattern: " << pattern << endl;

    KMPSearch(text, pattern);

    return 0;
}

                    </code>
                </pre>
            </p>
            <h2>7. Graph Algorithms</h2>
            <p style="color: white;">
                1. Challenges in Learning/Understanding Graph Algorithms<br>
                - Grasping different graph representations like adjacency lists and matrices.<br>
                - Understanding traversal techniques like BFS, DFS, and their recursive/iterative implementations.<br><br>

                2. Challenges in Correlating with Real-World Applications<br>
                - Connecting graph algorithms to practical problems like shortest path calculation in GPS, network optimization, or social network analysis.<br>
                - Adapting algorithms to handle dynamic graphs or large-scale networks efficiently.<br><br>

                3. Determining the Efficient Approach<br>
                - Identify the specific problem type (e.g., shortest path, minimum spanning tree, or connectivity).<br>
                - Compare algorithms based on their suitability for the problem (e.g., Dijkstra’s for non-negative weights, Bellman-Ford for graphs with negative weights).
           <pre>
               <code>
                   #include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

// Function to implement Dijkstra's Algorithm
void dijkstra(int source, const vector<vector<pair<int, int>>>& graph, int vertices) {
    // Priority queue to store {distance, vertex}, sorted by distance (min-heap)
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    // Distance vector to store the shortest distances from the source
    vector<int> distance(vertices, INT_MAX);

    // Initialize the source vertex
    distance[source] = 0;
    pq.push({0, source});

    while (!pq.empty()) {
        int currentDistance = pq.top().first;
        int currentNode = pq.top().second;
        pq.pop();

        // Check all adjacent vertices of the current node
        for (const auto& neighbor : graph[currentNode]) {
            int adjacentNode = neighbor.first;
            int weight = neighbor.second;

            // Relaxation step: Update the distance if a shorter path is found
            if (distance[currentNode] + weight < distance[adjacentNode]) {
                distance[adjacentNode] = distance[currentNode] + weight;
                pq.push({distance[adjacentNode], adjacentNode});
            }
        }
    }

    // Print the shortest distances
    cout << "Shortest distances from source vertex " << source << ":\n";
    for (int i = 0; i < vertices; i++) {
        if (distance[i] == INT_MAX) {
            cout << "Vertex " << i << ": Unreachable\n";
        } else {
            cout << "Vertex " << i << ": " << distance[i] << "\n";
        }
    }
}

int main() {
    int vertices = 5;

    // Graph represented as an adjacency list
    // Each pair is {adjacent vertex, weight}
    vector<vector<pair<int, int>>> graph(vertices);

    // Example edges
    graph[0].push_back({1, 10});
    graph[0].push_back({4, 5});
    graph[1].push_back({2, 1});
    graph[1].push_back({4, 2});
    graph[2].push_back({3, 4});
    graph[3].push_back({0, 7});
    graph[3].push_back({2, 6});
    graph[4].push_back({1, 3});
    graph[4].push_back({2, 9});
    graph[4].push_back({3, 2});

    int source = 0;
    dijkstra(source, graph, vertices);

    return 0;
}

               </code>
           </pre>
            </p>
        </div>
    </section>

</body>
</html>

